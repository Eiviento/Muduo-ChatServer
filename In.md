首先在chatserver.cpp中初始化聊天服务器对象，其实就是起一个服务端的网络链接，

会有两个回调函数一个是connection，该回调函数主要用于服务器接收客户端的链接请求，

​	该回调函数只有一个参数，那就是所接收到的客户端连接请求fd。

​	主要是用于判断客户端是否还在链接，如果客户端的连接断开，那么就关闭该fd的请求。

另一个是onmessage回调函数，该函数主要用于上报客户端的读写请求信息。

​	该回调函数有三个参数，包括连接客户端的fd信息，Buffer缓冲区，以及一个超时时间time。

​	首先把从客户端中读取到的字符串信息通过json反序列化，json中会包含一个“msgid”字段，这个是功能码，每个不同的功能码绑定了对应的函数句柄，通过将函数句柄传入回调函数实现业务的解析操作。



chatservice.hpp	

  {"help", "显示所有支持的命令，格式help"},

  {"chat", "一对一聊天，格式**chat:friendid:message**"},

  {"addfriend", "添加好友，格式**addfriend:friendid**"},

  {"creategroup", "创建群组，格式**creategroup:groupname:groupdesc**"},

  {"addgroup", "加入群组，格式**addgroup:groupid**"},

  {"groupchat", "群聊，格式**groupchat:groupid:message**"},

  {"loginout", "注销，格式**loginout**"}};



回调函数以及函数句柄的实现都在chatservice.h中，消息id和其对应的业务处理方法存储在哈希表数据结构中，unordered<int,Msghandler> _userConnMap。

已登录的用户存储在一个哈希表中unordered<int,TcpConnnectionPtr> _userConnMap中，我门可以直接拿到他的conn连接，往该连接直接发送对应的消息。该链接的IO检测到可读之后会将消息打印出来。这样就完成了对应的聊天消息。如果用户不在线的话，那么会将消息存储在一个离线消息数据表中，每个用户一上线都要先检查离线消息数据表中有没有对应自己id的离线消息，如果有就将该消息取出，数据库中的该条记录也对应进行删除。

获取到对应的消息id，消息id里面的每一个数字代表一个业务逻辑，从哈希表中拿出对应id所要执行的指针代码。



以登录为例，将json字符串中对应的字段进行解析出来，首先通过在我们的数据库里面查询对应的用户id，然后查询该用户id的密码和我们输入的是否一致。一致则进行登录，反之则进行退出。登陆成功会将该用户的好友信息进行一个返回。

以聊天为例，首先我们输入聊天的消息号，判断索要聊天的用户是否在线，有一个对应的数据库文件在里面。如果用户在线直接通过conn描述符进行连接，反之则存储在离线消息中。

  {"msgid":1,"id":13,"password":123456}   

{"msgid":5,"id":13,"from":"zhangsan","toid":15,"msg":"hello"}





其中数据库对应的操作以及不同数据表的操作都单独封装在对应model文件中。可以直接调用进行功能的实现，实现了业务模块和数据库模块的解耦，不需要每次进行业务的时候创建对应的mysql然后对数据库进行操作，代码更加简洁。